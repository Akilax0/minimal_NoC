$date
	Tue Nov 14 18:00:23 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module ni_tb $end
$var wire 32 ! core_read_data [31:0] $end
$var reg 1 " clk $end
$var reg 1 # core_read_en $end
$var reg 32 $ core_write_addr [31:0] $end
$var reg 32 % core_write_data [31:0] $end
$var reg 1 & core_write_en $end
$var reg 1 ' reset $end
$scope module my_ni $end
$var wire 2 ( bresp [1:0] $end
$var wire 1 " clk $end
$var wire 1 # core_read_en $end
$var wire 32 ) core_write_addr [31:0] $end
$var wire 32 * core_write_data [31:0] $end
$var wire 1 & core_write_en $end
$var wire 1 ' reset $end
$var wire 2 + rresp [1:0] $end
$var wire 1 , write_en $end
$var wire 64 - write_data [63:0] $end
$var wire 1 . wready $end
$var wire 1 / rvalid $end
$var wire 1 0 read_en $end
$var wire 32 1 read_data [31:0] $end
$var wire 64 2 read64_data [63:0] $end
$var wire 5 3 ocup [4:0] $end
$var wire 1 4 full $end
$var wire 1 5 error $end
$var wire 1 6 empty $end
$var wire 32 7 core_read_data [31:0] $end
$var wire 1 8 bvalid $end
$var wire 1 9 awready $end
$var wire 1 : arready $end
$var reg 1 ; arvalid $end
$var reg 1 < awvalid $end
$var reg 1 = bready $end
$var reg 1 > rready $end
$var reg 1 ? wvalid $end
$scope module slave $end
$var wire 1 " aclk $end
$var wire 32 @ araddr [31:0] $end
$var wire 1 A arestn $end
$var wire 1 ; arvalid $end
$var wire 32 B awaddr [31:0] $end
$var wire 1 < awvalid $end
$var wire 1 = bready $end
$var wire 2 C bresp [1:0] $end
$var wire 32 D rdata [31:0] $end
$var wire 32 E read_data [31:0] $end
$var wire 1 > rready $end
$var wire 2 F rresp [1:0] $end
$var wire 32 G wdata [31:0] $end
$var wire 1 . wready $end
$var wire 1 ? wvalid $end
$var wire 64 H write_data [63:0] $end
$var wire 1 I reset $end
$var wire 1 4 full $end
$var wire 1 6 empty $end
$var reg 1 : arready $end
$var reg 1 9 awready $end
$var reg 1 8 bvalid $end
$var reg 1 0 read_en $end
$var reg 1 / rvalid $end
$var reg 1 , write_en $end
$upscope $end
$scope module write_fifo $end
$var wire 1 " clk $end
$var wire 64 J data_in [63:0] $end
$var wire 1 0 read_en $end
$var wire 1 ' reset $end
$var wire 1 , write_en $end
$var reg 64 K data_out [63:0] $end
$var reg 1 6 empty $end
$var reg 1 5 error $end
$var reg 5 L fifo_ocup [4:0] $end
$var reg 1 4 full $end
$var reg 5 M next_read_ptr [4:0] $end
$var reg 5 N next_write_ptr [4:0] $end
$var reg 5 O ocup [4:0] $end
$var reg 5 P read_ptr_ff [4:0] $end
$var reg 5 Q write_ptr_ff [4:0] $end
$var integer 32 R i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
1I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
0A
b0 @
0?
0>
0=
0<
0;
0:
09
08
b0 7
16
x5
04
b0 3
b0 2
b0 1
x0
0/
0.
b0 -
x,
b0 +
b0 *
b0 )
b0 (
1'
0&
b0 %
b0 $
0#
1"
b0 !
$end
#4000
0,
#5000
0"
#10000
b100000 R
1"
#15000
0"
#20000
1.
19
1=
1?
1<
1"
b10101010101010101010101010101010 %
b10101010101010101010101010101010 *
b10101010101010101010101010101010 G
b1010010110100101101001011010010110101010101010101010101010101010 -
b1010010110100101101001011010010110101010101010101010101010101010 H
b1010010110100101101001011010010110101010101010101010101010101010 J
b10100101101001011010010110100101 $
b10100101101001011010010110100101 )
b10100101101001011010010110100101 B
1&
0I
1A
0'
#25000
0"
#30000
b1 N
1,
0.
09
0?
0<
1"
#32000
b0 N
0,
18
#35000
0"
#40000
1:
0=
1>
1;
1"
b0 %
b0 *
b0 G
b0 -
b0 H
b0 J
b0 $
b0 )
b0 B
1#
0&
#42000
08
#45000
0"
#50000
15
1/
0:
10
1;
1"
